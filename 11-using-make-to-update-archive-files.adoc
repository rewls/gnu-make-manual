= 11 Using make to Update Archive Files
:source-highlighter: rouge
:toc: left

* _Archive files_ are files containing named sub-files called _members_; they
  are maintained with the program `ar` and their main use is as subroutine
  libraries for linking.

== 11.1 Archive Members as Targets

* An individual member of an archive file can be used as a target or
  prerequisite in `make`.
* You specify the member named _member_ in archive file _archive_ as follows:

[source,makefile,subs="+quotes"]
_archive_(_member_)

* This construct is available only in targets and prerequisites, not in
  recipes!
* Most programs that you might use in recipes do not support this syntax and
  cannot act directly on archive members.
* Only `ar` and other programs specifically designed to operate on archives
  can do so.
* Therefore, valid recipes to update an archive member target probably must
  use `ar`.
* For example, this rule says to create a member `hack.o` in archive `foolib`
  by copying the file `hack.o`:

[,makefile]
----
foolib(hack.o) : hack.o
	ar cr foolib hack.o
----

* In fact, nearly all archive member targets are updated in just this way and
  there is an implicit rule to do it for you.
* Please note: The 'c' flag to `ar` is required if the archive file does not
  already exist.

'''

* To specify several members in the same archive, you can write all the member
  names together between the parentheses.
* For example:
+
[source,makefile]
foolib(hack.o kludge.o)
+
is equivalent to:
+
[source,makefile]
foolib(hack.o) foolib(kludge.o)


'''

* You can also use shell-style wildcards in an archive member reference.
* See Section 4.3 [Using Wildcard Characters in File Names], page 25.
* For example, `foolib(*.o)` expands to all existing members of the `foolib`
  archive whose names end in `.o`; perhaps `foolib(hack.o) foolib(kludge.o)`.

== 11.2 Implicit Rule for Archive Member Targets

* Recall that a target that looks like `_a_(_m_)` stands for the member named
  _m_ in the archive file _a_.

'''

* When `make` looks for an implicit rule for such a target, as a special
  feature it considers implicit rules that match `(_m_)`, as well as those
  that match the actual target `_a_(_m_)`.

'''

* This causes one special rule whose target is (`%`) to match.
* This rule updates the target `_a_(_m_)` by copying the file _m_ into the
  archive.
* For example, it will update the archive member target `foo.a(bar.o)` by
  copying the file `bar.o` into the archive `foo.a` as a member named `bar.o`.

'''

* When this rule is chained with others, the result is very powerful.
* Thus, `make "foo.a(bar.o)"` (the quotes are needed to protect the `(` and
  `)` from being interpreted specially by the shell) in the presence of a file
  `bar.c` is enough to cause the following recipe to be run, even without a
  makefile:

....
cc -c bar.c -o bar.o
ar r foo.a bar.o
rm -f bar.o
....

* Here `make` has envisioned the file `bar.o` as an intermediate file.
* See Section 10.4 [Chains of Implicit Rules], page 127.

'''

* Implicit rules such as this one are written using the automatic variable
  `$%`. See Section 10.5.3 [Automatic Variables], page 130.

'''

* An archive member name in an archive cannot contain a directory name, but it
  may be useful in a makefile to pretend that it does.
* If you write an archive member target `foo.a(dir/file.o)`, make will perform
  automatic updating with this recipe:
+
....
ar r foo.a dir/file.o
....
+
which has the effect of copying the file `dir/file.o` into a member named
`file.o`.
* In connection with such usage, the automatic variables `%D` and `%F` may be
  useful.

== 11.3 Dangers When Using Archives

* The built-in rules for updating archives are incompatible with parallel
  builds.
* These rules (required by the POSIX standard) add each object file into the
  archive as it's compiled.
* When parallel builds are enabled this allows multiple `ar` commands to be
  updating the same archive simultaneously, which is not supported.

'''

* If you want to use parallel builds with archives you can override the
  default rules by adding these lines to your makefile:

[,makefile]
----
(%) : % ;
%.a : ; $(AR) $(ARFLAGS) $@ $?
----

'''

* The first line changes the rule that updates an individual object in the
  archive to do nothing, and the second line changes the default rule for
  building an archive to update all the outdated objects (`$?`) in one
  command.
* Of course you will still need to declare the prerequisites of your library
  using the archive syntax:

[source,makefile]
libfoo.a: libfoo.a(x.o y.o ...)

* If you prefer to write an explicit rule you can use:

[,makefile]
----
libfoo.a: libfoo.a(x.o y.o ...)
	$(AR) $(ARFLAGS) $@ $?
----
