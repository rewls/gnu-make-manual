# 2. An Introduction to Makefiles

- You need a file called a *makefile* to tell `make` what to do.

- In this chapter, we will discuss a simple makefile that describes how to compile and link a text editor which consists of eight C source files and three header files.

    - To see a more complex example of a makefile, see Appendix C [Complex Makefile].

## 2.1. What a Rule Looks Like

- A simple makefile consists of "rules" with the following shape:

```makefile
*target* ... : *prerequisites* ...
	*recipe*
	...
	...
```

- A *target* is usually the name of a file that is generated by a program.

    - A target can also be the name of an action to carry out, such as `clean` (see Section 4.5 [Phony Targets]).

- A *prerequisite* is a file that is used as input to create the target.

- A *recipe* is an action that `make` carries out.

    - You need to put a tab character at the beginning of every recipe line!

    - If you prefer to prefix your recipes with a character other than tab, you can set the `.RECIPEPREFIX` variable to an alternate character (see Section 6.14 [Special Variables]).

- Usually a recipe is in a rule with prerequisites and serves to create a target file if any of the prerequisite change.

- The rule that specifies a recipe for the target need not have prerequisites.

- A *rule* explains how and when to remake certain files which are the targets of the particular rule.

- A rule can also explain how and when to carry out an action.

    - See Chapter 4 [Writing Rules].

## 2.2. A Simple Makefile

- Here is a straightforward makefile that describes the way an executable file called `edit` depends on eight object files which, in turn, depend on eight C source and three header files.

- In this example, all the C files include `defs.h`, but only those defining editing commands include `command.h`, and only low level files that change the editor buffer include `buffer.h`.

```makefile
edit : main.o kbd.o command.o display.o \
	insert.o search.o files.o utils.o
	cc -o edit main.o kbd.o command.o display.o \
		insert.o search.o files.o utils.o

main.o : main.c defs.h
	cc -c main.c
kbd.o : kbd.c defs.h command.h
	cc -c kbd.c
command.o : command.c defs.h command.h
	cc -c command.c
display.o : display.c defs.h buffer.h
	cc -c display.c
insert.o : insert.c defs.h buffer.h
	cc -c insert.c
search.o : search.c defs.h buffer.h
	cc -c search.c
files.o : files.c defs.h buffer.h command.h
	cc -c files.c
utils.o : utils.c defs.h
	cc -c utils.c
clean :
	rm edit main.o kbd.o command.o display.o \
		insert.o search.o files.o utils.o
```

- We split each long line into two lines using backslash/newline.

    - See Section 3.1.1 [Splitting Long Lines].

- To use this makefile to create the executable file called `edit`, type:

```sh
make
```

- To use this makefile to delete the executable file and all the object files from the directory, type:

```sh
make clean
```

- Targets that do not refer to files but are just actions are called *phony targets*.

    - See Section 4.5 [Phony Targets] for information about this kind of target.

- See Section 5.5 [Errors in Recipes] to see how to cause `make` to ignore errors from `rm` or any other command.

## 2.3. How `make` Processes a Makefile

- By default, `make` starts with the first target (not targets whose names start with '.' unless they also contain one or more '/').

- This is called the *default goal*.

- You can override this behavior using the command line (see Section 9.2 [Arguments to Specify the Goals]) or with the `.DEFAULT_GOAL` special variable (see Section 6.14 [Other Special Variables]).

- `make` reads the makefile in the current directory.

## 2.4. Variables Make Makefiles Simpler

- In our example, we had to list all the object files twice in the rule for `edit`.

- *Variables* allow a text string to be defined once and substituted in multiple places later (see Chapter 6 [How to Use Variables]).

- It is standard practice for every makefile to have a variable named `objects`, `OBJECTS`, `objs`, `OBJS`, `obj`, or `OBJ` which is a list of all object file names.

```makefile
objects = main.o kbd.o command.o display.o \
	  insert.o search.o files.o utils.o
```

- Each place we want to put a list of the object file names, we can substitute the variable's value by writing '`$(objects)`' (see Chapter 6 [How to Use Variables]).

```makefile
objects = main.o kbd.o command.o display.o \
	  insert.o search.o files.o utils.o

edit : $(objects)
	cc -o edit $(objects)
main.o : main.c defs.h
	cc -c main.c
kbd.o : kbd.c defs.h command.h
	cc -c kbd.c
command.o : command.c defs.h command.h
	cc -c command.c
display.o : display.c defs.h buffer.h
	cc -c display.c
insert.o : insert.c defs.h buffer.h
	cc -c insert.c
search.o : search.c defs.h buffer.h
	cc -c search.c
files.o : files.c defs.h buffer.h command.h
	cc -c files.c
utils.o : utils.c defs.h
	cc -c utils.c
clean :
	rm edit $(objects)
```

## 2.5. Letting `make` Deduce the Recipes

- `make` has an *implicit rule* for updating a '`.o`' file from a correspondingly named '`.c`' file using a '`cc -c`' command.

- We can therefore omit the recipes from the rules for the  object files.

    - See Chapter 10 [Using Implicit Rules].

- When a '`.c`' file is used automatically in this way, it is also automatically added to the list of prerequisites.

- We can therefore omit the '`.c`' files from the prerequisites.

```makefile
objects = main.o kbd.o command.o display.o \
	  insert.o search.o files.o utils.o

edit : $(objects)
	cc -o edit $(objects)

main.o : defs.h
kbd.o : defs.h command.h
command.o : defs.h command.h
display.o : defs.h buffer.h
insert.o : defs.h buffer.h
search.o : defs.h buffer.h
files.o : defs.h buffer.h command.h
utils.o : defs.h

.PHONY : clean
clean :
	rm edit $(objects)
```

- This is how we would write the makefile in actual practice.

- The complications associated with '`clean`' are described elsewhere.

    - See Section 4.5 [Phony Targets] and Section 5.5 [Errors in Recipes].

## 2.6. Another Style of Makefile

- When the objects of a makefile are created only by implicit rules, an alternative style of makefile is possible.

- In this style of makefile, you group entries by their prerequisites instead of by their targets.

```makefile
objects = main.o kbd.o command.o display.o \
	  insert.o search.o files.o utils.o

edit : $(objects)
	cc -o edit $(objects)

$(objects) : defs.h
kbd.o command.o files.o : command.h
display.o insert.o search.o files.o : buffer.h
```

## 2.7. Rules for Cleaning the Directory

- In practice, we might want  to write the rule in a somewhat more complicated manner to handle unanticipated situations.

```makefile
.PHONY : clean
clean :
	-rm edit $(objects)
```

- This prevents `make` from getting confused by an actual file called `clean` and causes it to continue in spite of errors from `rm`.

    - See Section 4.5 [Phony Targets] and Section 5.5 [Errors in Recipes].

- Since `clean` is not a prerequisites of `edit`, in order to make the rule run, we have to type '`make clean`'.

    - See Chapter 9 [How to Run `make`].
