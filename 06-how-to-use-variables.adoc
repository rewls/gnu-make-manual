= 6 How to Use Variables
:source-highlighter: rouge
:tabsize: 8
:toc: left

* A _variable_ is a name defined in a makefile to represent a string of text,
  called the variable's _value_.
* These values are substituted by explicit request into targets,
  prerequisites, recipes, and other parts of the makefile.
* (In some other versions of `make`, variables are called _macros_.)

'''

* Variables and functions in all parts of a makefile are expanded when read,
  except for in recipes, the right-hand sides of variable definitions using
  '```=```', and the bodies of variable definitions using the `define` directive.
* The value a variable expands to is that of its most recent definition at the
  time of expansion.
* In other words, variables are dynamically scoped.

'''

* Variables can represent lists of file names, options to pass to compilers,
  programs to run, directories to look in for source files, directories to
  write output in, or anything else you can imagine.
* A variable name may be any sequence of characters not containing '```:```',
  '```#```', '```=```', or whitespace.
* However, variable names containing characters other than letters, numbers,
  and underscores should be considered carefully, as in some shells they
  cannot be passed through the environment to a sub-make (see Section 5.7.2
  [Communicating Variables to a Sub-make], page 57).
* Variable names beginning with '```.```' and an uppercase letter may be given
  special meaning in future versions of `make`.

'''

* Variable names are case-sensitive.
* The names '```foo```', '```FOO```', and '```Foo```' all refer to different
  variables.

'''

* It is traditional to use upper case letters in variable names, but we
  recommend using lower case letters for variable names that serve internal
  purposes in the makefile, and reserving upper case for parameters that
  control implicit rules or for parameters that the user should override with
  command options (see Section 9.5 [Overriding Variables], page 113).

'''

* A few variables have names that are a single punctuation character or just a
  few characters.
* These are the _automatic variables_, and they have particular specialized
  uses.
* See Section 10.5.3 [Automatic Variables], page 130.

== 6.1 Basics of Variable References

* To substitute a variable's value, write a dollar sign followed by the name
  of the variable in parentheses or braces: either '```$(foo)```' or
  '```${foo}```' is a valid reference to the variable `foo`.
* This special significance of '```$```' is why you must write '```$$```' to
  have the effect of a single dollar sign in a file name or recipe.

'''

* Variable references can be used in any context: targets, prerequisites,
  recipes, most directives, and new variable values.
* Here is an example of a common case, where a variable holds the names of all
  the object files in a program:

[,makefile]
----
objects = program.o foo.o utils.o
program : $(objects)
	cc -o program $(objects)

$(objects) : defs.h
----

'''

* Variable references work by strict textual substitution.
* Thus, the rule
+
[source,makefile]
foo = c
prog.o : prog.$(foo)
	$(foo)$(foo) -$(foo) prog.$(foo)
+
could be used to compile a C program `prog.c`.
* Since spaces before the variable value are ignored in variable assignments,
  the value of `foo` is precisely '```c```'.
* (Don't actually write your makefiles this way!)

'''

* A dollar sign followed by a character other than a dollar sign,
  open-parenthesis or open-brace treats that single character as the variable
  name.
* Thus, you could reference the variable `x` with '```$x```'.
* However, this practice can lead to confusion (e.g., '```$foo```' refers to
  the variable `f` followed by the string `oo`) so we recommend using
  parentheses or braces around all variables, even single-letter variables,
  unless omitting them gives significant readability improvements.
* One place where readability is often improved is automatic variables (see
  Section 10.5.3 [Automatic Variables], page 130).

== 6.2 The Two Flavors of Variables

* There are different ways that a variable in GNU `make` can get a value; we
  call them the _flavors_ of variables.
* The flavors are distinguished in how they handle the values they are
  assigned in the makefile, and in how those values are managed when the
  variable is later used and expanded.

=== 6.2.1 Recursively Expanded Variable Assignment

* The first flavor of variable is a _recursively expanded variable_.
* Variables of this sort are defined by lines using '```=```' (see Section 6.5
  [Setting Variables], page 72) or by the `define` directive (see Section 6.8
  [Defining Multi-Line Variables], page 76).
* The value you specify is installed verbatim; if it contains references to
  other variables, these references are expanded whenever this variable is
  substituted (in the course of expanding some other string).
* When this happens, it is called _recursive expansion_.

'''

* For example,
+
[,makefile]
----
foo = $(bar)
bar = $(ugh)
ugh = Huh?

all:;echo $(foo)
----
+
will echo '```Huh?```': '```$(foo)```' expands to '```$(bar)```' which expands
to '```$(ugh)```' which finally expands to '```Huh?```'.

'''

* This flavor of variable is the only sort supported by most other versions of
  `make`.
* It has its advantages and its disadvantages.
* An advantage (most would say) is that:
+
[source,makefile]
CFLAGS = $(include_dirs) -O
include_dirs = -Ifoo -Ibar
+
will do what was intended: when '```CFLAGS```' is expanded in a recipe, it
will expand to '```-Ifoo -Ibar -O```'.
* A major disadvantage is that you cannot append something on the end of a
  variable, as in

[source,makefile]
CFLAGS = $(CFLAGS) -O
+
because it will cause an infinite loop in the variable expansion.
* (Actually `make` detects the infinite loop and reports an error.)

'''

* Another disadvantage is that any functions (see Chapter 8 [Functions for
  Transforming Text], page 91) referenced in the definition will be executed
  every time the variable is expanded.
* This makes `make` run slower; worse, it causes the `wildcard` and `shell`
  functions to give unpredictable results because you cannot easily control
  when they are called, or even how many times.

=== 6.2.2 Simply Expanded Variable Assignment

* To avoid the problems and inconveniences of recursively expanded variables,
  there is another flavor: simply expanded variables.

'''

* _Simply expanded variables_ are defined by lines using '```:=```' or
  '```::=```' (see Section 6.5 [Setting Variables], page 72).
* Both forms are equivalent in GNU `make`; however only the '```::=```' form
  is described by the POSIX standard (support for '```::=```' is added to the
  POSIX standard for POSIX Issue 8).

'''

* The value of a simply expanded variable is scanned once, expanding any
  references to other variables and functions, when the variable is defined.
* Once that expansion is complete the value of the variable is never expanded
  again: when the variable is used the value is copied verbatim as the
  expansion.
* If the value contained variable references the result of the expansion will
  contain their values _as of the time this variable was defined_.
* Therefore,
+
[source,makefile]
x := foo
y := $(x) bar
x := later
+
is equivalent to
+
[source,makefile]
y := foo bar
x := later

* Here is a somewhat more complicated example, illustrating the use of
  '```:=```' in conjunction with the `shell` function.
* (See Section 8.14 [The `shell` Function], page 107.)
* This example also shows use of the variable `MAKELEVEL`, which is changed
  when it is passed down from level to level.
* (See Section 5.7.2 [Communicating Variables to a Sub-make], page 57, for
  information about `MAKELEVEL`.)

[source,makefile]
ifeq (0,${MAKELEVEL})
whoami := $(shell whoami)
host-type := $(shell arch)
MAKE := ${MAKE} host-type=${host-type} whoami=${whoami}
endif

* An advantage of this use of '```:=```' is that a typical 'descend into a
  directory' recipe then looks like this:

[source,makefile]
${subdirs}:
	${MAKE} -C $@ all

* Simply expanded variables generally make complicated makefile programming
  more predictable because they work like variables in most programming
  languages.
* They allow you to redefine a variable using its own value (or its value
  processed in some way by one of the expansion functions) and to use the
  expansion functions much more efficiently (see Chapter 8 [Functions for
  Transforming Text], page 91).

'''

* You can also use them to introduce controlled leading whitespace into
  variable values.
* Leading whitespace characters are discarded from your input before
  substitution of variable references and function calls; this means you can
  include leading spaces in a variable value by protecting them with variable
  references, like this:

[source,makefile]
nullstring :=
space := $(nullstring) # end of the line

* Here the value of the variable `space` is precisely one space.
* The comment '```# end of the line```' is included here just for clarity.
* Since trailing space characters are not stripped from variable values, just
  a space at the end of the line would have the same effect (but be rather
  hard to read).
* If you put whitespace at the end of a variable value, it is a good idea to
  put a comment like that at the end of the line to make your intent clear.
* Conversely, if you do not want any whitespace characters at the end of your
  variable value, you must remember not to put a random comment on the end of
  the line after some whitespace, such as this:

[source,makefile]
dir := /foo/bar    # directory to put the frobs in

* Here the value of the variable `dir` is ‘/foo/bar ’ (with four trailing
  spaces), which was probably not the intention.
* (Imagine something like '```$(dir)/file```' with this definition!)

=== 6.2.3 Immediately Expanded Variable Assignment

* Another form of assignment allows for immediate expansion, but unlike simple
  assignment the resulting variable is recursive: it will be re-expanded again
  on every use.
* In order to avoid unexpected results, after the value is immediately
  expanded it will automatically be quoted: all instances of `$` in the value
  after expansion will be converted into `$$`.
* This type of assignment uses the ‘:::=’ operator.
* For example,
+
[source,makefile]
var = first
OUT :::= $(var)
var = second
+
results in the `OUT` variable containing the text '```first```', while here:
+
[source,makefile]
var = one$$two
OUT :::= $(var)
var = three$$four
+
results in the `OUT` variable containing the text '```one$$two```'.
* The value is expanded when the variable is assigned, so the result is the
  expansion of the first value of `var`, '```one$two```'; then the value is
  re-escaped before the assignment is complete giving the final result of
  '```one$$two```'.

'''

* The variable `OUT` is thereafter considered a recursive variable, so it will
  be re-expanded when it is used.

'''

* This seems functionally equivalent to the '```:=```' / '```::=```'
  operators, but there are a few differences:

'''

* First, after assignment the variable is a normal recursive variable; when
  you append to it with '```+=```' the value on the right-hand side is not
  expanded immediately.
* If you prefer the '```+=```' operator to expand the right-hand side
  immediately you should use the '```:=```' / '```::=```' assignment instead.

'''

* Second, these variables are slightly less efficient than simply expanded
  variables since they do need to be re-expanded when they are used, rather
  than merely copied.
* However since all variable references are escaped this expansion simply
  un-escapes the value, it won't expand any variables or run any functions.

'''

* Here is another example:

[source,makefile]
var = one$$two
OUT :::= $(var)
OUT += $(var)
var = three$$four

'''

* After this, the value of `OUT` is the text '```one$$two $(var)```'.
* When this variable is used it will be expanded and the result will be
  '```one$two three$four```'.

'''

* This style of assignment is equivalent to the traditional BSD `make`
  '```:=```' operator; as you can see it works slightly differently than the
  GNU `make` '```:=```' operator.
* The `:::=` operator is added to the POSIX specification in Issue 8 to
  provide portability.

=== 6.2.4 Conditional Variable Assignment

* There is another assignment operator for variables, '```?=```'.
* This is called a conditional variable assignment operator, because it only
  has an effect if the variable is not yet defined.
* This statement:
+
[source,makefile]
FOO ?= bar
+
is exactly equivalent to this (see Section 8.11 [The `origin` Function], page
104):
+
[source,makefile]
ifeq ($(origin FOO), undefined)
  FOO = bar
endif

* Note that a variable set to an empty value is still defined, so '```?=```' will
  not set that variable.
