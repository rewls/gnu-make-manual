= 6 How to Use Variables
:source-highlighter: rouge
:tabsize: 8
:toc: left

* A _variable_ is a name defined in a makefile to represent a string of text,
  called the variable's _value_.
* These values are substituted by explicit request into targets,
  prerequisites, recipes, and other parts of the makefile.
* (In some other versions of `make`, variables are called _macros_.)

'''

* Variables and functions in all parts of a makefile are expanded when read,
  except for in recipes, the right-hand sides of variable definitions using
  '```=```', and the bodies of variable definitions using the `define` directive.
* The value a variable expands to is that of its most recent definition at the
  time of expansion.
* In other words, variables are dynamically scoped.

'''

* Variables can represent lists of file names, options to pass to compilers,
  programs to run, directories to look in for source files, directories to
  write output in, or anything else you can imagine.
* A variable name may be any sequence of characters not containing '```:```',
  '```#```', '```=```', or whitespace.
* However, variable names containing characters other than letters, numbers,
  and underscores should be considered carefully, as in some shells they
  cannot be passed through the environment to a sub-make (see Section 5.7.2
  [Communicating Variables to a Sub-make], page 57).
* Variable names beginning with '```.```' and an uppercase letter may be given
  special meaning in future versions of `make`.

'''

* Variable names are case-sensitive.
* The names '```foo```', '```FOO```', and '```Foo```' all refer to different
  variables.

'''

* It is traditional to use upper case letters in variable names, but we
  recommend using lower case letters for variable names that serve internal
  purposes in the makefile, and reserving upper case for parameters that
  control implicit rules or for parameters that the user should override with
  command options (see Section 9.5 [Overriding Variables], page 113).

'''

* A few variables have names that are a single punctuation character or just a
  few characters.
* These are the _automatic variables_, and they have particular specialized
  uses.
* See Section 10.5.3 [Automatic Variables], page 130.

== 6.1 Basics of Variable References

* To substitute a variable's value, write a dollar sign followed by the name
  of the variable in parentheses or braces: either '```$(foo)```' or
  '```${foo}```' is a valid reference to the variable `foo`.
* This special significance of '```$```' is why you must write '```$$```' to
  have the effect of a single dollar sign in a file name or recipe.

'''

* Variable references can be used in any context: targets, prerequisites,
  recipes, most directives, and new variable values.
* Here is an example of a common case, where a variable holds the names of all
  the object files in a program:

[,makefile]
----
objects = program.o foo.o utils.o
program : $(objects)
	cc -o program $(objects)

$(objects) : defs.h
----

'''

* Variable references work by strict textual substitution.
* Thus, the rule
+
[source,makefile]
foo = c
prog.o : prog.$(foo)
	$(foo)$(foo) -$(foo) prog.$(foo)
+
could be used to compile a C program `prog.c`.
* Since spaces before the variable value are ignored in variable assignments,
  the value of `foo` is precisely '```c```'.
* (Don't actually write your makefiles this way!)

'''

* A dollar sign followed by a character other than a dollar sign,
  open-parenthesis or open-brace treats that single character as the variable
  name.
* Thus, you could reference the variable `x` with '```$x```'.
* However, this practice can lead to confusion (e.g., '```$foo```' refers to
  the variable `f` followed by the string `oo`) so we recommend using
  parentheses or braces around all variables, even single-letter variables,
  unless omitting them gives significant readability improvements.
* One place where readability is often improved is automatic variables (see
  Section 10.5.3 [Automatic Variables], page 130).

== 6.2 The Two Flavors of Variables

* There are different ways that a variable in GNU `make` can get a value; we
  call them the _flavors_ of variables.
* The flavors are distinguished in how they handle the values they are
  assigned in the makefile, and in how those values are managed when the
  variable is later used and expanded.

=== 6.2.1 Recursively Expanded Variable Assignment

* The first flavor of variable is a _recursively expanded variable_.
* Variables of this sort are defined by lines using '```=```' (see Section 6.5
  [Setting Variables], page 72) or by the `define` directive (see Section 6.8
  [Defining Multi-Line Variables], page 76).
* The value you specify is installed verbatim; if it contains references to
  other variables, these references are expanded whenever this variable is
  substituted (in the course of expanding some other string).
* When this happens, it is called _recursive expansion_.

'''

* For example,
+
[,makefile]
----
foo = $(bar)
bar = $(ugh)
ugh = Huh?

all:;echo $(foo)
----
+
will echo '```Huh?```': '```$(foo)```' expands to '```$(bar)```' which expands
to '```$(ugh)```' which finally expands to '```Huh?```'.

'''

* This flavor of variable is the only sort supported by most other versions of
  `make`.
* It has its advantages and its disadvantages.
* An advantage (most would say) is that:
+
[source,makefile]
CFLAGS = $(include_dirs) -O
include_dirs = -Ifoo -Ibar
+
will do what was intended: when '```CFLAGS```' is expanded in a recipe, it
will expand to '```-Ifoo -Ibar -O```'.
* A major disadvantage is that you cannot append something on the end of a
  variable, as in
+
[source,makefile]
CFLAGS = $(CFLAGS) -O
+
because it will cause an infinite loop in the variable expansion.
* (Actually `make` detects the infinite loop and reports an error.)

'''

* Another disadvantage is that any functions (see Chapter 8 [Functions for
  Transforming Text], page 91) referenced in the definition will be executed
  every time the variable is expanded.
* This makes `make` run slower; worse, it causes the `wildcard` and `shell`
  functions to give unpredictable results because you cannot easily control
  when they are called, or even how many times.

=== 6.2.2 Simply Expanded Variable Assignment

* To avoid the problems and inconveniences of recursively expanded variables,
  there is another flavor: simply expanded variables.

'''

* _Simply expanded variables_ are defined by lines using '```:=```' or
  '```::=```' (see Section 6.5 [Setting Variables], page 72).
* Both forms are equivalent in GNU `make`; however only the '```::=```' form
  is described by the POSIX standard (support for '```::=```' is added to the
  POSIX standard for POSIX Issue 8).

'''

* The value of a simply expanded variable is scanned once, expanding any
  references to other variables and functions, when the variable is defined.
* Once that expansion is complete the value of the variable is never expanded
  again: when the variable is used the value is copied verbatim as the
  expansion.
* If the value contained variable references the result of the expansion will
  contain their values _as of the time this variable was defined_.
* Therefore,
+
[source,makefile]
x := foo
y := $(x) bar
x := later
+
is equivalent to
+
[source,makefile]
y := foo bar
x := later

* Here is a somewhat more complicated example, illustrating the use of
  '```:=```' in conjunction with the `shell` function.
* (See Section 8.14 [The `shell` Function], page 107.)
* This example also shows use of the variable `MAKELEVEL`, which is changed
  when it is passed down from level to level.
* (See Section 5.7.2 [Communicating Variables to a Sub-make], page 57, for
  information about `MAKELEVEL`.)

[source,makefile]
ifeq (0,${MAKELEVEL})
whoami := $(shell whoami)
host-type := $(shell arch)
MAKE := ${MAKE} host-type=${host-type} whoami=${whoami}
endif

* An advantage of this use of '```:=```' is that a typical 'descend into a
  directory' recipe then looks like this:

[source,makefile]
${subdirs}:
	${MAKE} -C $@ all

* Simply expanded variables generally make complicated makefile programming
  more predictable because they work like variables in most programming
  languages.
* They allow you to redefine a variable using its own value (or its value
  processed in some way by one of the expansion functions) and to use the
  expansion functions much more efficiently (see Chapter 8 [Functions for
  Transforming Text], page 91).

'''

* You can also use them to introduce controlled leading whitespace into
  variable values.
* Leading whitespace characters are discarded from your input before
  substitution of variable references and function calls; this means you can
  include leading spaces in a variable value by protecting them with variable
  references, like this:

[source,makefile]
nullstring :=
space := $(nullstring) # end of the line

* Here the value of the variable `space` is precisely one space.
* The comment '```# end of the line```' is included here just for clarity.
* Since trailing space characters are not stripped from variable values, just
  a space at the end of the line would have the same effect (but be rather
  hard to read).
* If you put whitespace at the end of a variable value, it is a good idea to
  put a comment like that at the end of the line to make your intent clear.
* Conversely, if you do not want any whitespace characters at the end of your
  variable value, you must remember not to put a random comment on the end of
  the line after some whitespace, such as this:

[source,makefile]
dir := /foo/bar    # directory to put the frobs in

* Here the value of the variable `dir` is ‘/foo/bar ’ (with four trailing
  spaces), which was probably not the intention.
* (Imagine something like '```$(dir)/file```' with this definition!)

=== 6.2.3 Immediately Expanded Variable Assignment

* Another form of assignment allows for immediate expansion, but unlike simple
  assignment the resulting variable is recursive: it will be re-expanded again
  on every use.
* In order to avoid unexpected results, after the value is immediately
  expanded it will automatically be quoted: all instances of `$` in the value
  after expansion will be converted into `$$`.
* This type of assignment uses the ‘:::=’ operator.
* For example,
+
[source,makefile]
var = first
OUT :::= $(var)
var = second
+
results in the `OUT` variable containing the text '```first```', while here:
+
[source,makefile]
var = one$$two
OUT :::= $(var)
var = three$$four
+
results in the `OUT` variable containing the text '```one$$two```'.
* The value is expanded when the variable is assigned, so the result is the
  expansion of the first value of `var`, '```one$two```'; then the value is
  re-escaped before the assignment is complete giving the final result of
  '```one$$two```'.

'''

* The variable `OUT` is thereafter considered a recursive variable, so it will
  be re-expanded when it is used.

'''

* This seems functionally equivalent to the '```:=```' / '```::=```'
  operators, but there are a few differences:

'''

* First, after assignment the variable is a normal recursive variable; when
  you append to it with '```+=```' the value on the right-hand side is not
  expanded immediately.
* If you prefer the '```+=```' operator to expand the right-hand side
  immediately you should use the '```:=```' / '```::=```' assignment instead.

'''

* Second, these variables are slightly less efficient than simply expanded
  variables since they do need to be re-expanded when they are used, rather
  than merely copied.
* However since all variable references are escaped this expansion simply
  un-escapes the value, it won't expand any variables or run any functions.

'''

* Here is another example:

[source,makefile]
var = one$$two
OUT :::= $(var)
OUT += $(var)
var = three$$four

'''

* After this, the value of `OUT` is the text '```one$$two $(var)```'.
* When this variable is used it will be expanded and the result will be
  '```one$two three$four```'.

'''

* This style of assignment is equivalent to the traditional BSD `make`
  '```:=```' operator; as you can see it works slightly differently than the
  GNU `make` '```:=```' operator.
* The `:::=` operator is added to the POSIX specification in Issue 8 to
  provide portability.

=== 6.2.4 Conditional Variable Assignment

* There is another assignment operator for variables, '```?=```'.
* This is called a conditional variable assignment operator, because it only
  has an effect if the variable is not yet defined.
* This statement:
+
[source,makefile]
FOO ?= bar
+
is exactly equivalent to this (see Section 8.11 [The `origin` Function], page
104):
+
[source,makefile]
ifeq ($(origin FOO), undefined)
  FOO = bar
endif

* Note that a variable set to an empty value is still defined, so '```?=```' will
  not set that variable.

== 6.3 Advanced Features for Reference to Variables

* This section describes some advanced features you can use to reference
  variables in more flexible ways.

=== 6.3.1 Substitution References

* A _substitution reference_ substitutes the value of a variable with
  alterations that you specify.
* It has the form '```$(var:__a__=_b_)```' (or '```${var:__a__=_b_}```') and
  its meaning is to take the value of the variable _`var_, replace every _a_
  at the end of a word with _b_ in that value, and substitute the resulting
  string.

'''

* When we say "at the end of a word", we mean that _a_ must appear either
  followed by whitespace or at the end of the value in order to be replaced;
  other occurrences of _a_ in the value are unaltered.
* For example:
+
[source,makefile]
foo := a.o b.o l.a c.o
bar := $(foo:.o=.c)
+
sets '```bar```' to '```a.c b.c l.a c.c```'.
* See Section 6.5 [Setting Variables], page 72.

'''

* A substitution reference is shorthand for the `patsubst` expansion function
  (see Section 8.2 [Functions for String Substitution and Analysis], page 92):
  '```$(var:__a__=_b_)```' is equivalent to '```$(patsubst %_a_,%_b_,_var_)```'.
* We provide substitution references as well as `patsubst` for compatibility
  with other implementations of `make`.

'''

* Another type of substitution reference lets you use the full power of the
  `patsubst` function.
* It has the same form '```$(var:__a__=_b_)```' described above, except that
  now _a_ must contain a single '```%```' character.
* This case is equivalent to '```$(patsubst _a_,_b_,$(_var_))```'.
* See Section 8.2 [Functions for String Substitution and Analysis], page 92,
  for a description of the `patsubst` function.
* For example:
+
[source,makefile]
foo := a.o b.o l.a c.o
bar := $(foo:%.o=%.c)
+
sets '```bar```' to '```a.c b.c l.a c.c```'.

=== 6.3.2 Computed Variable Names

* Computed variable names are an advanced concept, very useful in more
  sophisticated makefile programming.
* In simple situations you need not consider them, but they can be extremely
  useful.

'''

* Variables may be referenced inside the name of a variable.
* This is called a _computed variable name_ or a _nested variable reference_.
* For example,
+
[source,makefile]
x = y
y = z
a := $($(x))
+
defines `a` as '```z```': the '```$(x)```' inside '```$($(x))```' expands to
'```y```', so '```$($(x))```' expands to '```$(y)```' which in turn expands to
'```z```'.
* Here the name of the variable to reference is not stated explicitly; it is
  computed by expansion of '```$(x)```'.
* The reference '```$(x)```' here is nested within the outer variable
  reference.

'''

* The previous example shows two levels of nesting, but any number of levels
  is possible.
* For example, here are three levels:
+
[source,makefile]
x = y
y = z
z = u
a := $($($(x)))

* Here the innermost '```$(x)```' expands to '```y```', so '```$($(x))```'
  expands to '```$(y)```' which in turn expands to '```z```'; now we have
  '```$(z)```', which becomes '```u```'.

'''

* References to recursively-expanded variables within a variable name are
  re-expanded in the usual fashion.
* For example:
+
[source,makefile]
x = $(y)
y = z
z = Hello
a := $($(x))
+
defines '```a```' as '```Hello```': '```$($(x))```' becomes '```$($(y))```'
which becomes '```$(z)```' which becomes '```Hello```'.

'''

* Nested variable references can also contain modified references and function
  invocations (see Chapter 8 [Functions for Transforming Text], page 91), just
  like any other reference.
* For example, using the `subst` function (see Section 8.2 [Functions for
  String Substitution and Analysis], page 92):
+
[source,makefile]
x = variable1
variable2 := Hello
y = $(subst 1,2,$(x))
z = y
a := $($($(z)))
+
eventually defines `a` as '```Hello```'.
* It is doubtful that anyone would ever want to write a nested reference as
  convoluted as this one, but it works: '```$($($(z)))```' expands to
  '```$($(y))```' which becomes '```$($(subst 1,2,$(x)))```'.
* This gets the value '```variable1```' from `x` and changes it by
  substitution to '```variable2```', so that the entire string becomes
  '```$(variable2)```', a simple variable reference whose value is
  '```Hello```'.

'''

* A computed variable name need not consist entirely of a single variable
  reference.
* It can contain several variable references, as well as some invariant text.
* For example,
+
[,makefile]
----
a_dirs := dira dirb
1_dirs := dir1 dir2

a_files := filea fileb
1_files := file1 file2

ifeq "$(use_a)" "yes"
a1 := a
else
a1 := 1
endif

ifeq "$(use_dirs)" "yes"
df := dirs
else
df := files
endif

dirs := $($(a1)_$(df))
----
+
will give `dirs` the same value as `a_dirs`, `1_dirs`, `a_files` or `1_files`
depending on the settings of `use_a` and `use_dirs`.

'''

* Computed variable names can also be used in substitution references:
+
[,makefile]
----
a_objects := a.o b.o c.o
1_objects := 1.o 2.o 3.o

sources := $($(a1)_objects:.o=.c)
----
+
defines sources as either '```a.c b.c c.c```' or '```1.c 2.c 3.c```',
depending on the value of `a1`.

'''

* The only restriction on this sort of use of nested variable references is
  that they cannot specify part of the name of a function to be called.
* This is because the test for a recognized function name is done before the
  expansion of nested references.
* For example,
+
[,makefile]
----
ifdef do_sort
func := sort
else
func := strip
endif

bar := a d b g q c

foo := $($(func) $(bar))
----
+
attempts to give '```foo```' the value of the variable '```sort a d b g q
c```' or '```strip a d b g q c```', rather than giving '```a d b g q c```' as
the argument to either the `sort` or the `strip` function.
* This restriction could be removed in the future if that change is shown to
  be a good idea.

'''

* You can also use computed variable names in the left-hand side of a variable
  assignment, or in a `define` directive, as in:
+
[source,makefile]
dir = foo
$(dir)_sources := $(wildcard $(dir)/*.c)
define $(dir)_print =
lpr $($(dir)_sources)
endef

* This example defines the variables '```dir```', '```foo_sources```', and
  '```foo_print```'.

'''

* Note that nested variable references are quite different from recursively
  expanded variables (see Section 6.2 [The Two Flavors of Variables], page
  66), though both are used together in complex ways when doing makefile
  programming.
